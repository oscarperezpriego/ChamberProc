---
title: ChamberFlux (working title)
subtitle: An adapted version of the R package "RespChamberFlux" to calculate gas fluxes measured with the PICARRO system (SUBTITLE TO BE ADAPTED)" 
author: "Michael Strupler, Jesús Fernandez Habas, Adrián González Guzmán,Vidal Barrón López de Torre, Oscar Pérez-Priego"
date: last-modified
format:
  html:
    code-fold: false
  # pdf:
  #   geometry: 
  #     - top=30mm
  #     - left=30mm
execute:
  echo: false
bibliography: '../publication2024/bibliography.bib'
csl: '../publication2024/natural-hazards.csl'
---

```{r}
#| label: load-pkgs
#| message: false

library("rlang")
library("changepoint")
library("nlme")
library("segmented")
library("tibble")
library("plyr")
library("dplyr")
library("purrr")
library("RespChamberProc")
library("devtools")
library("stringr")
library("ggplot2")
library("data.table")
library("lubridate") 
library("tidyr")
library("plyr")
library("doSNOW")
```

```{r}
#| label: project-setup
#| message: false
#| warning: false

latDeciDeg <-37.91514875822371 #enter here latitude in Geographical Coordinates (decimal degrees); crs =4326)
lonDeciDeg <-4.72405536319233 #enter here longitude in Decimal Degrees
  
fileName <- "JFAADS2174-20220531-080209-DataLog_User.dat" #set here file name
data_pathname <- "../data/" #"Data_Adrian/Agosto/19/"
results_pathname <- "../"

newpackagename <- "[NEWPACKAGENAME]" #enter here the name of the R package

#create folder with the name of the measurement archive to save results and plots therein
dir.create(paste0(results_pathname,"results"))

results_dir <- paste0(results_pathname,"results/",str_sub(fileName,end=-18))
dir.create(results_dir)
```

# Introduction

## Background and Challenges

\[Broad overview about gas flux measurements in general\] Measuring gas fluxes in a chamber provides useful information on plant-atmosphere interactions and processes (e.g. REF). However, each measurement includes systematic and random errors (e.g. @Perez-Priego2015)

The package *RespChamberFlux* (@RespChamberProc) derives fluxes from a time series of gas concentrations in a chamber. It has been successfully used in past studies (@Perez-Priego2015a,@Perez-Priego2021) for chamber measurements with a LI-840 infrared gas analyzer (IRGA LI-840, Lincoln, NE, USA) system. The chambers were equipped with different sensors to acquire environmental variables, and specifically the gases CO2 and H2O.

\[Quickly introduce Picarro system\]: The *Picarro* system (REF) has been used for various gas flux measurements for various settings, including field campaigns executed by the Agronomy Department of the University of Córdoba, Spain (ADD REFS TO STUDIES). An advantage of the Picarro system is that it can measure a broad range of gases from a chamber, including CO2, H2O, N2O, NH3, AND CH4. However, various environmental variables, including Temperature, Atmospheric Pressure, relative humidity, and shortwave radiation were not measured during the above mentionend campaigns.

To our knowledge, no evaluation of the measurement times needed for each gas to minimize systematic and aleatory errors, exists.

## Aims and structure of this article

In this article, we present *`r newpackagename`* that builds on the R (@RSoftware) package *RespChamberFlux* (@RespChamberProc), suited for the use with the *Picarro* system (Reference). We demonstrate the use of the package for Picarro measurement data from two case studies located in Córdoba, Spain (ADD STUDY SITE FIGURE) with different aims. Furthermore, we systematically test the gas-specific measurement times in the Picarro system that are needed in order to minimize the measurement error. Based on our findings, we provide recommendations for minimizing systematic and random errors when measuring with the Picarro system.

## RespChamberProc 
To provide the reader with the necessary background how RespChamberProc (@RespChamberProc) works, a quick overview of RespChamberFlux is provided in the following. As stated above, the package was developed to compute the fluxes and to estimate the associated errors for gases for a chamber. Generally, the package performs the following steps:

1.  data loading
2.  corrections of units and gas densities (Gases have to be in dry mole fractions)
3.  identification of single measurement chunks (labelled with an index variable)
4.  estimation of the fluxes and their respective errors

For *`r newpackagename`*, the here presented Picarro-adapted version of RespChamberProc, we demonstrate each of these steps based on example data in the results section.

# Methodology

All calculations in this article are executed using R Statistical Software version `r paste(version$major,version$minor,sep=".")` (@RSoftware).

## Adapting RespChamberProc to use with the Picarro system

We extended the package *RespChamberFlux* (@RespChamberProc) by various functionalities:

-   Time intervals in the raw data from Picarro are irregular $\rightarrow$ convertToRegularTimesteps
-   A function was implemented that downloads additional environmental parameters automatically for selected coordinates using the packages "openmeteo" (@Openmeteo) and "elevatr" (@ElevatR).

## Analyzing the gas-specific measurement times needed for error minimization

We analyze the gas-specific measurement times that are needed for the used set-up in order to minimize the errors by 
[create plots!] 
<!-- How do fluxes and uncertainties vary with the selection of the calculation window? -->

# Results

```{r}
#| label: read-and-prepare-data
#| message: false
#| warning: false


ds0 <- fread(paste0(data_pathname,fileName), sep ="auto")
ds0$TIMESTAMP <- as.POSIXct(paste0(ds0$DATE," ",ds0$TIME), "%Y-%m-%d %H:%M:%S", tz= "UTC")
## The logger is accumulating data from previous field campaigns. 
#  Here we subset data from a given field campaign. (Entrar hora del inicio de observationes y fin (convert to UTC))
ds <- subset(ds0, as.numeric(TIMESTAMP) >= as.numeric(as.POSIXctUTC("2022-05-31 08:00:00")) )
ds <- subset(ds, as.numeric(TIMESTAMP) <= as.numeric(as.POSIXctUTC("2022-05-31 12:00:00" )) )
```

```{r}
#| label: load-additional-functions
#| message: false
#| warning: false

source("functions/getAdditionalWeatherVariables.R") # load function to automatically get elevation (AWS Mapzen elevation tiles: https://registry.opendata.aws/terrain-tiles/) T and atmospheric pressure (data: https://open-meteo.com/en/docs/historical-weather-api) for a sampling location (to be entered in decimal degrees below)
source("functions/convertToRegularTimesteps.R") # load function to interpolate measurement data to regular timesteps
source("functions/ChunkPlots.R") # load function to generate plots for each chunk for various gases
```

```{r}
#| label: all-gases
#| message: false
#| warning: false

Additional_Weather_Data <- getAdditionalWeatherVariables(latDeciDeg, lonDeciDeg,format(min(ds$TIMESTAMP),"%Y-%m-%d"),format(max(ds$TIMESTAMP),"%Y-%m-%d"))


# For the case of PICARRO IRGA gives dry mole fractions for CO2, N2O, CH4, but not for NH3 and H2O 
ds$solenoid_valvesInt <- ds$solenoid_valves %>% as.integer()
ds$H2Oppt <- ds$H2O*10 # H2O from PICARRO is in %.Needs to be in ppt --> We need to multiply by 10 
ds$N2O_dry <- ds$N2O_dry1min
ds$NH3_dry <- 10E-3*corrConcDilution(ds, colConc = "NH3", colVapour = "H2Oppt")  #NH3 from PICARRO is in ppb --> multiply colVapour by 10^-3 to get ppm
ds$H2O_dry <- corrConcDilution(ds, colConc = "H2Oppt", colVapour = "H2Oppt")

## (h, Pa, and AirTemp are obtained directly from freely available Meteo and Elevation data for given coordinates during the measurement time interval with the "getElevationAndAtmosphericPressure" script (see details therein). If desired, it can also be set here manually)
# ds$h = 106 # Córdoba elevation (m above sea level)
# ds$Pa <- 101325*(1 - 2.25577*10^-5*h)^5.25588   # (Pa)
# ds$AirTemp <- 25 #(degrees Celsius)

ds$VPD <- calcVPD( ds$AirTemp, ds$Pa, ds$H2Oppt) ## Here we calculate plant-to-air vapour pressure deficit

#--Extract duplicated rows
ds <- ds[!duplicated(ds$TIMESTAMP),]

#-- In order to process each measurement cycle independently, 
#-- we first determine parts of the time series that are contiguous, 
#-- i.e. without gaps and without change of an index variable, here variable collar.
Collar_df <- tibble("TIMESTAMP"=ds$TIMESTAMP,"Collar"=ds$solenoid_valvesInt)

# interpolate measurement timestamps for whole dataset
##create  continuous timestamp vector (here: interval=1 second)
regular_timesteps <- seq(min(ds$TIMESTAMP),max(ds$TIMESTAMP), by="1 sec")


ds <-convertToRegularTimesteps(ds,c("CO2_dry", "CH4_dry","H2Oppt", "NH3_dry","N2O_dry"),regular_timesteps)
ds <- left_join(ds,Collar_df,by=join_by("TIMESTAMP"=="TIMESTAMP")) %>% fill(.,Collar,.direction="down")

#join Temp_PressureData with ds  (approx does not work for more following NA's, just fill nas with same value as last one (function "fill" from tidyr package))
ds <- left_join(ds,Additional_Weather_Data ,by=join_by("TIMESTAMP"=="DATETIME_hourly")) %>% fill(.,h,AirTemp,Pa,rel_humidity,shortwave_radiation,ET0, .direction = "updown")


## get an overview of the data (for the whole subset)
#p_collar <- plot(ds$TIMESTAMP,ds$Collar, pch = ".", ylab = "Collar (Chamber)",xlab = "Time")

### facet plot of time series (for whole subset)
ds_gas_long <- gather(ds, key="gas", value="value", c("CO2_dry","H2Oppt","CH4_dry","NH3_dry","N2O_dry"))
p_gas_facet <- ggplot(ds_gas_long, aes(x=TIMESTAMP, y=value))+
  ggtitle(format(ds$TIMESTAMP,"%d/%m/%Y")[1])+
  geom_point(pch = ".")+
  facet_wrap(~factor(gas,levels=c("CO2_dry","H2Oppt","CH4_dry","NH3_dry","N2O_dry")),ncol=1,scales = "free")

ds_envar_long <- gather(ds, key="envar", value="value", c("AirTemp","Pa","rel_humidity","shortwave_radiation","ET0"))
p_envar_facet <-  ggplot(ds_envar_long, aes(x=TIMESTAMP, y=value))+
  ggtitle(format(ds$TIMESTAMP,"%d/%m/%Y")[1])+
  geom_point(pch = ".")+
  facet_wrap(~factor(envar,levels=c("AirTemp","Pa","rel_humidity","shortwave_radiation","ET0")),ncol=1,scales = "free")


```

```{r}
#| label: create-chunks
#| message: false

# Chunk creation ----------------------------------------------------------

dsChunk <- subsetContiguous(ds, colTime = "TIMESTAMP", colIndex = "Collar",
                            gapLength = 1, minNRec = 180, minTime = 180, indexNA = 13) #indexNA excludes selected index columns (here: collar)
head_dsChunk <- head(dsChunk)


# plot the time series ----------------------------------------------------

# Generate labels for each gas
labels_CO2 <- chunk_labels(dsChunk, CO2_dry, 1.05)
labels_H2O <- chunk_labels(dsChunk, H2Oppt, 1.05)
labels_CH4 <- chunk_labels(dsChunk, CH4_dry, 1.05)
labels_N2O <- chunk_labels(dsChunk, N2O_dry, 1.05)
labels_NH3 <- chunk_labels(dsChunk, NH3_dry, 1.05)

# Generate plots for each gas
p_CO2 <- chunk_plot(dsChunk, CO2_dry, labels_CO2, y_CO2)
p_H2O <- chunk_plot(dsChunk, H2Oppt, labels_H2O, y_H2O)
p_CH4 <- chunk_plot(dsChunk, CH4_dry, labels_CH4, y_CH4)
p_N2O <- chunk_plot(dsChunk, N2O_dry, labels_N2O, y_N2O)
p_NH3 <- chunk_plot(dsChunk, NH3_dry, labels_NH3, y_NH3)

##save the plots
# for (p in c("p_CO2","p_H2O","p_CH4","p_N2O","p_NH3")) {
#   ggsave(filename=paste0(results_dir,"/",str_sub(fileName,end=-18),"_allchunks_",p,".pdf"),get(p),width = 40,height = 30,units = "cm")
# }

```

```{r}
## flag bad chunks (based on manual inspection of facet plots 1=good, 0=bad) --> maybe we can automatize this? QUESTION: WHAT IS A "GOOD" chunk? (criteria to automatize). ALTERNATIVE: WE ASSUME ALL CHUNKS AS GOOD AT THIS STAGE AND WILL REJECT CHUNKS WHERE SD > MEAN IN "res" object.
# goodChunks <- c(1,2,6,11,15,20,24,28,34,39,45,53,58,64,69,73,82,84,88,92,95,98,103,106,110,114,118,123,125,128,133,141,145,149,153,157,162,166,169,174,177,181,187,191,195,203,206)
# dsChunk$flag <- ifelse(dsChunk$iChunk %in% goodChunks,1,0)



#select only good chunks
# dsChunk <- dsChunk %>% filter(.,flag==1)

##select just one chunk
selected_chunk=4

df <- dsChunk[dsChunk$iChunk==selected_chunk,]
#plot(df$TIMESTAMP, df$CO2_dry)


# Computing the flux for single chunks ------------------------------------------------------


resFit <- calcClosedChamberFlux(df
                                , fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)
                                , colConc = "CO2_dry", colTime = "TIMESTAMP"	# colum names conc ~ timeInSeconds
                                , colTemp = "AirTemp", colPressure = "Pa"		#Temp in degC, Pressure in Pa
                                , volume = 0.4*0.4*0.4, area = 0.4*0.4			# chamber dimensions m3 and m2
                                , minTLag = 60,  maxLag = 150 ,concSensitivity = 0.01	
)



resH2OFit <- calcClosedChamberFlux(df
                                   , fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)
                                   , colConc = "H2Oppt", colTime = "TIMESTAMP"
                                   , colTemp = "AirTemp", colPressure = "Pa"	
                                   , volume = 0.4*0.4*0.4, area = 0.4*0.4				
                                   , minTLag = 60,  maxLag = 150 ,concSensitivity = 0.01	
)



resCH4Fit <- calcClosedChamberFlux(df
                                , fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)
                                , colConc = "CH4_dry", colTime = "TIMESTAMP"
                                , colTemp = "AirTemp", colPressure = "Pa"
                                , volume = 0.4*0.4*0.4, area = 0.4*0.4	
                                , minTLag = 60,  maxLag = 150 ,concSensitivity = 0.01	
)



resNH3Fit <- calcClosedChamberFlux(df
                                   , fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)
                                   , colConc = "NH3_dry", colTime = "TIMESTAMP"
                                   , colTemp = "AirTemp", colPressure = "Pa"
                                   , volume = 0.4*0.4*0.4, area = 0.4*0.4	
                                   , minTLag = 60,  maxLag = 150 ,concSensitivity = 0.01	
)

	

resN2OFit <- calcClosedChamberFlux(df
                                   , fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)
                                   , colConc = "N2O_dry", colTime = "TIMESTAMP"
                                   , colTemp = "AirTemp", colPressure = "Pa"
                                   , volume = 0.4*0.4*0.4, area = 0.4*0.4	
                                   , minTLag = 60,  maxLag = 150 , concSensitivity = 0.01	
)




```


```{r}
#| label: duration-uncertainty
#| eval: false

resDur <- plotDurationUncertainty( df, colTemp="AirTemp", volume = 0.4*0.4*0.4,
                                   fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare
                                                )
                                   , maxSdFlux = 0.8
                                   , nDur=10
                                   , durations = seq(60,240,30)
)

plot( flux ~ duration, resDur$statAll[[1]] )
plot( sdFlux ~ duration, resDur$statAll[[1]] )

resDur_H2O <- plotDurationUncertainty( df, colConc = "H2Oppt", colTemp="AirTemp", volume = 0.4*0.4*0.4,
                                   fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare
                                                )
                                   , maxSdFlux = 0.8
                                   , nDur=10
                                   , durations = seq(60,240,30)
)

plot( flux ~ duration, resDur_H2O$statAll[[1]] )
plot( sdFlux ~ duration, resDur_H2O$statAll[[1]] )

resDur_CH4 <- plotDurationUncertainty( df, colConc = "CH4_dry", colTemp="AirTemp", volume = 0.4*0.4*0.4,
                                   fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare
                                                )
                                   , maxSdFlux = 0.8
                                   , nDur=10
                                   , durations = seq(60,240,30)
)

plot( flux ~ duration, resDur_CH4$statAll[[1]] )
plot( sdFlux ~ duration, resDur_CH4$statAll[[1]] )

resDur_NH3 <- plotDurationUncertainty( df, colConc = "NH3_dry", colTemp="AirTemp", volume = 0.4*0.4*0.4,
                                   fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare
                                                )
                                   , maxSdFlux = 0.8
                                   , nDur=10
                                   , durations = seq(60,240,30)
)

plot( flux ~ duration, resDur_NH3$statAll[[1]] )
plot( sdFlux ~ duration, resDur_NH3$statAll[[1]] )

resDur_N2O <- plotDurationUncertainty( df, colConc = "NH3_dry", colTemp="AirTemp", volume = 0.4*0.4*0.4,
                                   fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare
                                                )
                                   , maxSdFlux = 0.8
                                   , nDur=10
                                   , durations = seq(60,240,30)
)

plot( flux ~ duration, resDur_N2O$statAll[[1]] )
plot( sdFlux ~ duration, resDur_N2O$statAll[[1]] )

#should we define a criterium here for SD time? (should we create a synthetic mean curve from all measurements?)

```





```{r}
#| label: compute-fluxes
#| eval: false

# Computing the fluxes in a field campaign --------------------------------
# -- Function calcClosedChamberFluxForChunks helps you with subsetting the data 
# -- and applying function calcClosedChamberFlux to each subset.


# chamberVol = 0.4*0.4*0.4
# surfaceArea = 0.4*0.4
# 
# nNode = 8	# number of processors
# cl = makeCluster(nNode)		
# registerDoSNOW(cl)
# clusterEvalQ(cl, library(RespChamberProc))		# functions need to be loaded on remote hosts
# 
# system.time(res <- ddply(dsChunk, .(iChunk), function(dsi){
#   collar <- dsi$Collar[1] 
#   iChunk = dsi$iChunk[1]
#   print( paste(iChunk, dsi$TIMESTAMP[1], " Collar: ",collar) ) 
#   
#   res <- calcClosedChamberFluxForChunks(
#     dsi, fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)	
#     #, debugInfo = list(omitEstimateLeverage = FALSE)	# faster
#     , colConc = "CO2_dry", colTime = "TIMESTAMP"	# colum names conc ~ timeInSeconds
#     , colTemp = "AirTemp", colPressure = "Pa"		# Temperature in K  (IS THAT TRUE IN K, OR DO WE NEED °C, AS STATED IN https://github.com/bgctw/RespChamberProc/blob/master/R/fluxEstimates.R), Pressure in Pa
#     , volume = chamberVol, area = surfaceArea					    # chamber dimensions m3 and m2
#     , minTLag = 60,  maxLag = 150 , concSensitivity = 0.01	
#   )
#   
#   resH2O <- calcClosedChamberFluxForChunks(
#     dsi, fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)	
#     #, debugInfo = list(omitEstimateLeverage = FALSE)	# faster
#     , colConc = "H2Oppt", colTime = "TIMESTAMP"	# colum names conc ~ timeInSeconds
#     , colTemp = "AirTemp", colPressure = "Pa"		
#     , volume = chamberVol, area = surfaceArea	
#     , minTLag = 60,  maxLag = 150 , concSensitivity = 0.01	
#   )
# 
#   resCH4 <- calcClosedChamberFluxForChunks(
#     dsi, fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)	
#     #, debugInfo = list(omitEstimateLeverage = FALSE)	# faster
#     , colConc = "CH4_dry", colTime = "TIMESTAMP"	# colum names conc ~ timeInSeconds
#     , colTemp = "AirTemp", colPressure = "Pa"		
#     , volume = chamberVol, area = surfaceArea	
#     , minTLag = 60,  maxLag = 150 , concSensitivity = 0.01	
#   )
# 
#   resNH3 <- calcClosedChamberFluxForChunks(
#     dsi, fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)	
#     #, debugInfo = list(omitEstimateLeverage = FALSE)	# faster
#     , colConc = "NH3_dry", colTime = "TIMESTAMP"	# colum names conc ~ timeInSeconds
#     , colTemp = "AirTemp", colPressure = "Pa"		
#     , volume = chamberVol, area = surfaceArea	
#     , minTLag = 60,  maxLag = 150 , concSensitivity = 0.01	
#   )
# 
#   resN2O <- calcClosedChamberFluxForChunks(
#     dsi, fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)	
#     #, debugInfo = list(omitEstimateLeverage = FALSE)	# faster
#     , colConc = "N2O_dry", colTime = "TIMESTAMP"	# colum names conc ~ timeInSeconds
#     , colTemp = "AirTemp", colPressure = "Pa"		
#     , volume = chamberVol, area = surfaceArea	
#     , minTLag = 60,  maxLag = 150 , concSensitivity = 0.01	
#   )
#   
#   
#   dsi$device
#   #   get additional environmental variables at the initial time
#   to <- res$tLag
#   to <- ifelse(to == 0, 1, to)
#   dsiInitial <- dsi[ to, , drop=FALSE]
#   cbind( data.frame( time=dsiInitial[,"TIMESTAMP"], collar=collar
#                      , CO2_flux=res$fluxMedian, CO2_flux_sd=res$sdFlux, Fregress_CO2=res$iFRegress, r2_CO2=res$r2
#                      , H2O_flux=resH2O$fluxMedian , H2O_flux_sd=resH2O$sdFlux, Fregress_H2O=resH2O$iFRegress, r2_H2O=resH2O$r2
#                      , CH4_flux=resCH4$fluxMedian, CH4_flux_sd=resCH4$sdFlux, Fregress_CH4=resCH4$iFRegress, r2_CH4=resCH4$r2
#                      , NH3_flux=resNH3$fluxMedian, NH3_flux_sd=resNH3$sdFlux, Fregress_NH3=resNH3$iFRegress, r2_NH3=resNH3$r2
#                      , N2O_flux=resN2O$fluxMedian , N2O_flux_sd=resN2O$sdFlux, Fregress_N2O=resN2O$iFRegress, r2_N2O=resN2O$r2
#   )
#   , dsiInitial[,c("CO2_dry","CH4_dry","NH3_dry","N2O_dry", "AirTemp","Pa")] )
#   
# }
# ))
# 
# aver <- calcClosedChamberFluxForChunks(
#   dsChunk, fRegress = c(lin = regressFluxLinear, tanh = regressFluxTanh, exp = regressFluxExp, poly= regressFluxSquare)	
#   , debugInfo = list(omitEstimateLeverage = FALSE)	# faster
#   , colConc = "CO2_dry", colTime = "TIMESTAMP"	# colum names conc ~ timeInSeconds
#   , colTemp = "AirTemp", colPressure = "Pa"	
#   , volume = chamberVol, area = surfaceArea					    # chamber dimensions m3 and m2
#   , minTLag = 200,  maxLag = 250 , concSensitivity = 0.1
# )
# 
# 
# #Plot the results including the fits as facet plots
# CO2_fit_facets <- plotCampaignConcSeries(dsChunk,aver, plotsPerPage = 64L)
# print( CO2_fit_facets$plot[[1]])
# 
# #flag chunks that are categorized as bad (i.e. if sd>mean, flag==0 (bad); else flag == 1). TO DISCUSS: So far only implemented for CO2. FOR EACH GAS, OR IS THERE A GAS THAT MOSTLY WORKS? we should do this step earlier to save computation time
# res$flag <-  ifelse(abs(aver$fluxMedian) > abs(aver$sdFlux) & res$r2_CO2 > 0.8 ,1,0)
# 
# #select only good chunks
# onlygoodresults<- res %>% filter(.,flag==1)
# 
# #save results file
# save(res, file=paste0(results_dir,"/",str_sub(fileName,end=-18),".Rda"))

```

## Case study: Data Jesus (HOW IS THE STUDY SITE CALLED?)

### Overview of the measurement data

The entire time series of the Picarro measurement data on `r format(ds$TIMESTAMP,"%d/%m/%Y")[1]` for the study site XXX (REF to figure studysite) are shown in @fig-gas_facet.

```{r}
#| label: fig-gas_facet
#| fig-cap: !expr paste("Entire time series of for the gases CO2, H2O, CH4, NH3, and N2O measured with the Picarro system on", format(ds$TIMESTAMP,"%d/%m/%Y")[1])
#| fig-width: 10
#| fig-height: 5
#| fig-align: center
#| out-width: 100%
#| echo: false

p_gas_facet 
```

The function `subsetContiguous`from *RespChamberProc* subsets the entire time series into chunks that are identified by an index variable, here termed "Collar".

```{r}
#| label: fig-chunks
#| fig-cap: Compilation of various chunks that were created from the CO2 time series
#| fig-width: 10
#| fig-height: 5
#| fig-align: center
#| out-width: 100%
#| echo: false

p_CO2

```

The function `calcClosedChamberFlux` from *RespChamberProc* calculates the chamber flux for various gases and estimates the best fit, as shown in @fig-selectedchunk for chunk '`r selected_chunk`'

```{r}
#| label: fig-selectedchunk
#| layout-ncol: 2
#| fig-cap: Fitted trends for a selected chunk
#| fig-subcap: 
#|    - CO2
#|    - H2O
#|    - CH4
#|    - NH3
#|    - N2O

#| echo: false

plotResp(df, resFit, label = paste("Chunk",selected_chunk,sep = " "))	

plotResp(df, resH2OFit,colConc = "H2Oppt",ylab="H2O (ppt)", label = paste("Chunk",selected_chunk,sep = " "))	

plotResp(df, resCH4Fit,colConc = "CH4_dry",ylab="CH4_dry (ppm)", label = paste("Chunk",selected_chunk,sep = " "))	

plotResp(df, resNH3Fit,colConc = "NH3_dry",ylab="NH3_dry (ppm)", label = paste("Chunk",selected_chunk,sep = " "))

plotResp(df, resN2OFit,colConc = "N2O_dry",ylab="N2O_dry (ppm)", label = paste("Chunk",selected_chunk,sep = " "))	

```

# Discussion

# Conclusions

# References {.unnumbered}
